# Mercury — Localization Design

## Goals

- All user-facing UI strings are localized.
- Initial languages: English (default) and Simplified Chinese (`zh-Hans`).
- Debug issue strings are **not** localized — they are diagnostic text for developer inspection.
- Language follows the macOS system setting by default.
- Users can override the system language inside the app (General Settings → Language).
- A language change takes effect immediately without restarting the app.

---

## Architecture

### Why not `Bundle.main` directly

`Bundle.main` is fixed at process launch. `String(localized:)` and `Text(_:)` with no explicit bundle respect the process-level language, which cannot be changed at runtime. To support live switching, every string lookup must go through a runtime-swappable bundle.

### `LanguageManager` — singleton

`LanguageManager` is a global `@Observable` singleton (`LanguageManager.shared`). It owns:

- `bundle: Bundle` — the active localization bundle; all string lookups use this.
- `languageOverride: String?` — the user's explicit language code (`"en"`, `"zh-Hans"`, etc.); `nil` means follow the system.

Persistence key: `UserDefaults` key `App.language` (`String?`).

On init, `LanguageManager` reads the persisted override (or derives the best match from `Locale.preferredLanguages`) and resolves the corresponding `.lproj` bundle. On `setLanguage(_:)`, it updates both `UserDefaults` and `bundle`, which triggers re-rendering of every view that observes `localizationBundle` via the SwiftUI environment.

```swift
@Observable
final class LanguageManager {
    static let shared = LanguageManager()

    struct SupportedLanguage: Identifiable {
        let code: String        // BCP-47, e.g. "en", "zh-Hans"
        let displayName: String // shown in the picker as-is, no translation needed
        var id: String { code }
    }

    static let supported: [SupportedLanguage] = [
        .init(code: "en",      displayName: "English"),
        .init(code: "zh-Hans", displayName: "简体中文"),
    ]

    private(set) var bundle: Bundle = .main
    private(set) var languageOverride: String?   // nil = follow system

    private init() { /* load persisted override, resolve bundle */ }

    func setLanguage(_ code: String?) {
        // 1. Persist to UserDefaults("App.language")
        // 2. Resolve bundle for code (or system best-match when nil)
        // 3. self.bundle = resolved  →  @Observable notifies observers
        // 4. self.languageOverride = code
    }

    private func resolvedBundle(for code: String?) -> Bundle { … }
}
```

### SwiftUI Environment Key

```swift
private struct LocalizationBundleKey: EnvironmentKey {
    static let defaultValue: Bundle = .main
}

extension EnvironmentValues {
    var localizationBundle: Bundle {
        get { self[LocalizationBundleKey.self] }
        set { self[LocalizationBundleKey.self] = newValue }
    }
}
```

Injected at the root in `MercuryApp.swift`:

```swift
ContentView()
    .environmentObject(appModel)
    .environment(\.localizationBundle, LanguageManager.shared.bundle)
```

Because `LanguageManager` is `@Observable`, any change to `LanguageManager.shared.bundle` causes the `MercuryApp.body` to re-evaluate, propagating the new bundle down the entire view tree.

---

## String Storage — `Localizable.xcstrings`

A single Xcode String Catalog (`Mercury/Mercury/Localizable.xcstrings`) holds all translations. English strings are used as keys (source-as-key). The catalog manages English and `zh-Hans` columns.

### Usage in views

```swift
@Environment(\.localizationBundle) var bundle

Text("Add Feed", bundle: bundle)
Text("Save", bundle: bundle)
Label { Text("Syncing…", bundle: bundle) } icon: { Image(systemName: "arrow.triangle.2.circlepath") }
```

For interpolated strings:

```swift
Text("Feeds: \(n)", bundle: bundle)
// or
String(localized: "Feeds: \(n)", bundle: bundle)
```

### Usage in model-layer code

Model-layer functions that return display strings (e.g., `AgentRuntimeProjection`, `TranslationContracts`) cannot receive an `@Environment` value. They read `LanguageManager.shared.bundle` directly:

```swift
static func summaryNoContentStatus() -> String {
    String(localized: "No summary", bundle: LanguageManager.shared.bundle)
}
```

Because `LanguageManager.shared.bundle` is updated synchronously before the `@Observable` notification fires, the next call after a language change always returns the correct string.

### Debug issue strings

Strings written to `Debug Issues` are plain Swift string literals — **never** passed through `LanguageManager.shared.bundle` or `String(localized:)`. This is intentional: diagnostic content must be stable, language-independent, and readable by developers regardless of the user's locale setting.

---

## Settings UI

In `AppSettingsView.swift`, the `GeneralSettingsView` gains a `Language` section below `Sync`:

```
Language
  System (auto-detect)   ← default when override is nil
  English
  简体中文
```

The picker writes its selection through `LanguageManager.shared.setLanguage(_:)`. The UI updates live.

---

## Testing

Unit tests that exercise display strings (e.g., `AgentDisplayProjectionTests`) pass `Bundle.main` explicitly when constructing `AgentRuntimeDisplayStrings`. This keeps tests deterministic regardless of the system language or any persistent `App.language` override.

---

## Adding a New Language

1. **Translate**: In Xcode, open `Localizable.xcstrings`, click `+` in the language list, select the target language (e.g., `ja`), and fill in translations for all keys.
2. **Register**: In `LanguageManager.supported`, append one entry:
   ```swift
   .init(code: "ja", displayName: "日本語"),
   ```

No other code changes are needed. The Settings picker and language resolution logic pick up the new entry automatically.

---

## Stale String Keys in `Localizable.xcstrings`

Xcode marks an xcstrings entry as stale when its static extractor cannot find a matching string literal in any source file. Two legitimate sources of stale warnings exist:

**1. Dynamically constructed keys** (expected, harmless)

When a key is generated at runtime from data (e.g., `LocalizedStringKey(level.rawValue.capitalized)`), Xcode cannot match it statically. These warnings are permanent and should be tolerated. Leave a comment in the source near the construction site explaining which keys are generated:

```swift
// Keys: "Short", "Medium", "Detailed" — generated from SummaryDetailLevel.rawValue.capitalized
ForEach(SummaryDetailLevel.allCases, id: \.self) { level in
    Text(LocalizedStringKey(level.rawValue.capitalized), bundle: bundle).tag(level)
}
```

**2. Genuinely orphaned keys** (should be removed)

These arise from manual additions or source refactors. To audit:

```bash
# Replace KEY with the exact xcstrings key (case-sensitive, no quotes)
grep -rn '"KEY"' Mercury/Mercury/
```

If no hits: the key is unused. Delete the entry from `Localizable.xcstrings`.

If hits exist only as substrings of other literals (e.g., the key `"Save"` matches inside `"Auto-Save"`), verify the exact usage site with a more targeted search.

**Workflow summary**

1. Note the stale key from Xcode's issue list.
2. `grep -rn` for the key in `Mercury/Mercury/`.
3. If found at a dynamic construction site → tolerate; annotate in source.
4. If not found → delete the entry from xcstrings.
5. Rebuild to confirm no new warnings.

---

## Implementation Notes — Lessons Learned

These capture non-obvious problems and their resolutions from the initial implementation. Each is a pitfall worth remembering.

### Why `Bundle.main` returns the wrong language for the development locale

Xcode's xcstrings pipeline writes `.lproj` directories only for *added* languages. It does **not** write `en.lproj` for the development language (English). As a result:

- The bundle on disk contains `zh-Hans.lproj` but no `en.lproj`.
- `Bundle.main.preferredLocalizations` matches device locale against on-disk `.lproj` directories. With only `zh-Hans.lproj` present, it resolves to `["zh-Hans"]` — even on an English-language Mac.
- Any `Text("key")` or `String(localized:)` call that falls through to `Bundle.main` therefore returns Chinese.

**Fix — `passthroughBundle`**

For the development language, `LanguageManager` returns a bundle backed by an empty temporary directory with no `.strings` files:

```swift
private static let passthroughBundle: Bundle = {
    let dir = URL(fileURLWithPath: NSTemporaryDirectory())
        .appendingPathComponent("mercury-l10n-passthrough", isDirectory: true)
    try? FileManager.default.createDirectory(at: dir, withIntermediateDirectories: true)
    return Bundle(url: dir) ?? .main
}()
```

When `NSBundle` finds no `.strings` match, it falls through and returns the lookup key as-is. The key is the English source text, so lookup returns English directly without needing an `en.lproj` on disk.

`resolveBundle(for:)` detects the development language via `Bundle.main.developmentLocalization` and returns `passthroughBundle` for it. For all other languages it locates the corresponding `.lproj` bundle normally.

### Root observation site: computed property, not a wrapper view

The initial implementation used a wrapper view (`AppWindowRoot`) to inject the environment bundle and serve as the `@Observable` observation site. This broke `NavigationSplitView` column-width persistence because the extra view layer shifted the scene-storage key SwiftUI uses internally.

**Fix**: Remove the wrapper. The actual root view (`ContentView`) declares a computed property:

```swift
var bundle: Bundle { LanguageManager.shared.bundle }
```

Accessing `LanguageManager.shared` inside `View.body` registers observation automatically — SwiftUI re-evaluates `ContentView` when `bundle` changes and propagates the new value via `.environment(\.localizationBundle, bundle)`. No wrapper layer needed.

### `.help()` modifier ignores custom bundles

`View.help(_ label: LocalizedStringKey)` resolves the string through `Bundle.main` internally, bypassing any `.environment(\.localizationBundle, …)` value. Passing a `LocalizedStringKey` to `.help()` therefore always returns the main-bundle result (Chinese on this project's bundle).

**Fix**: Resolve the string explicitly before passing it to `.help()`:

```swift
// Wrong — resolves via Bundle.main:
.help("Share")

// Correct — resolves via the active bundle:
.help(String(localized: "Share", bundle: bundle))
```

The `String(localized:bundle:)` overload resolves immediately to a plain `String`; `.help(_ label: String)` accepts it without any further bundle resolution.

### `NSViewRepresentable` must sync locale-sensitive properties in `updateNSView`

`makeNSView` runs once. Properties set there (e.g., `NSSearchField.placeholderString`) are not re-applied when the localization bundle changes. The placeholder therefore stays in the original language after a live language switch.

**Fix**: Apply placeholder (and any other locale-sensitive property) in `updateNSView`, guarded to avoid unnecessary resets:

```swift
func updateNSView(_ nsView: NSSearchField, context: Context) {
    if nsView.placeholderString != placeholder {
        nsView.placeholderString = placeholder
    }
    // …other state sync…
}
```

The `placeholder` binding is already connected to the localized string at the call site, so `updateNSView` fires whenever the bundle changes and propagates the new translation.

### `.tabItem` content does not inherit the SwiftUI environment

`View.tabItem { … }` renders its content in a separate platform context that does not receive the SwiftUI `Environment`. Any `Label("key", systemImage:)` or `Text("key")` inside `tabItem` resolves against `Bundle.main` regardless of what bundle was injected via `.environment(\.localizationBundle, …)`.

**Fix**: Resolve the string to a plain `String` before constructing the `Label`:

```swift
// Wrong — resolves via Bundle.main:
.tabItem { Label("General", systemImage: "gearshape") }

// Correct — resolves via the active bundle:
.tabItem { Label(String(localized: "General", bundle: bundle), systemImage: "gearshape") }
```

The containing view must observe `LanguageManager` (e.g., via a computed property `var bundle: Bundle { LanguageManager.shared.bundle }`) so `tabItem` labels re-render on language change.

### `Picker(_ titleKey: LocalizedStringKey, …)` ignores custom bundles

The convenience initializer `Picker(_ titleKey: LocalizedStringKey, selection:)` resolves the title key against `Bundle.main`, bypassing any bundle injected via the SwiftUI environment. The label therefore stays in the wrong language even when the rest of the form switches correctly.

**Fix**: Use the closure form and resolve the label via `Text(label, bundle: bundle)`:

```swift
// Wrong — resolves via Bundle.main:
Picker(label, selection: $selection) { … }

// Correct — resolves via the active bundle:
Picker(selection: $selection) {
    // options…
} label: {
    Text(label, bundle: bundle)
}
```

`Text(_ key: LocalizedStringKey, bundle:)` accepts a `LocalizedStringKey` with an explicit bundle, so the existing `LocalizedStringKey`-typed `label` property does not need to change type.
